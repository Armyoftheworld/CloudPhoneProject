/* DO NOT EDIT THIS FILE - it is machine generated */
// javah -classpath . -jni com.army.scrcpy.server.PushStreamTools
// (no use)gcc -fPIC -shared -I /opt/jdk1.8.0_251/include -I /opt/jdk1.8.0_251/include/linux -I . -L . -Wl,--whole-archive -lrtmp pushStreamTools.cpp -o libpushstream.so -Wl,--no-whole-archive
// gcc -fPIC -shared -I /opt/jdk1.8.0_251/include -I /opt/jdk1.8.0_251/include/linux -I . pushStreamTools.cpp srs_librtmp.cpp -g -O0 -lstdc++ -o libpushstream.so
#include "jni.h"
#include "stdio.h"
#include "string.h"
#include "srs_librtmp.h"

srs_rtmp_t rtmp;

extern "C" {

void print(JNIEnv *env, const char *msg) {
    jclass clazz = env->FindClass("java/lang/System");
    jfieldID outId = env->GetStaticFieldID(clazz, "out", "Ljava/io/PrintStream;");
    jobject out = env->GetStaticObjectField(clazz, outId);
    clazz = env->GetObjectClass(out);
    jmethodID println = env->GetMethodID(clazz, "println", "(Ljava/lang/String;)V");
    env->CallVoidMethod(out, println, env->NewStringUTF(msg));
}

char *convertJByteaArrayToChars(JNIEnv *env, jbyteArray bytearray) {
    char *chars = NULL;
    jbyte *bytes;
    bytes = env->GetByteArrayElements(bytearray, 0);
    int chars_len = env->GetArrayLength(bytearray);
    chars = new char[chars_len + 1];
    memset(chars, 0, chars_len + 1);
    memcpy(chars, bytes, chars_len);
    chars[chars_len] = 0;
    env->ReleaseByteArrayElements(bytearray, bytes, 0);
    return chars;
}

/*
 * Class:     com_army_scrcpy_server_PushStreamTools
 * Method:    initRtmp
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_army_scrcpy_server_PushStreamTools_initRtmp
        (JNIEnv *env, jclass jclazz, jstring rtmpUrl) {
    const char *path = env->GetStringUTFChars(rtmpUrl, 0);
    rtmp = srs_rtmp_create(path);
    env->ReleaseStringUTFChars(rtmpUrl, path);
    if (srs_rtmp_handshake(rtmp) != 0) {
        print(env, "native handshake failure");
        return 0;
    }
    if (srs_rtmp_connect_app(rtmp) != 0) {
        print(env, "native connect_app failure");
        return 0;
    }
    if (srs_rtmp_publish_stream(rtmp) != 0) {
        print(env, "native publish_stream failure");
        return 0;
    }
    return 1;
}

/*
 * Class:     com_army_scrcpy_server_PushStreamTools
 * Method:    pushRawStream
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_army_scrcpy_server_PushStreamTools_pushRawStream
        (JNIEnv *env, jclass jclazz, jbyteArray data, jint pts, jint frameSize) {
    if (rtmp == NULL) {
        print(env, "native rtmp is null");
        return;
    }
    char *frame = convertJByteaArrayToChars(env, data);
    int ret = srs_h264_write_raw_frames(rtmp, frame, frameSize, pts, pts);
    if (ret == 0) {
        print(env, "native push stream success");
        return;
    }
    char *msg = new char[50];
    if (srs_h264_is_dvbsp_error(ret)) {
        sprintf(msg, "ignore drop video error, code=%d", ret);
        return;
    }
    if (srs_h264_is_duplicated_sps_error(ret)) {
        sprintf(msg, "ignore duplicated sps, code=%d", ret);
        return;
    }
    if (srs_h264_is_duplicated_pps_error(ret)) {
        sprintf(msg, "ignore duplicated pps, code=%d", ret);
        return;
    }
    sprintf(msg, "send h264 raw data failed. ret=%d", ret);

}
}
